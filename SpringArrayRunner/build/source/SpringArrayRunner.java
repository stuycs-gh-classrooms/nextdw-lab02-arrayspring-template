/* autogenerated by Processing revision 1293 on 2025-03-12 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class SpringArrayRunner extends PApplet {

/* ===================================
SpringArrayDriver (Most Work Goes Here)

You will write a program that creates an array or orbs. When run, the simulation should show the orbs being connected by springs, which will push and pull the orbs according to the spring force.

Earth gravity will be a toggelable option. As well as whether the simulation is running movement or not.

Part 0: Create and populate the array of orbs.
Part 1: Draw the "springs" connecting the orbs.
Part 2: Calculate and apply the spring force to the
        orbs in the array.
Part 3: Apply earth based gravity and drag if those
        options are turned on.
Part 4: Allow for the removal and addition of orbs
=================================== */


int NUM_ORBS = 10;
int MIN_SIZE = 10;
int MAX_SIZE = 60;
float MIN_MASS = 10;
float MAX_MASS = 100;
float G_CONSTANT = 1;
float D_COEF = 0.1f;

int SPRING_LENGTH = 50;
float  SPRING_K = 0.005f;

int MOVING = 0;
int BOUNCE = 1;
int GRAVITY = 2;
int DRAGF = 3;
boolean[] toggles = new boolean[4];
String[] modes = {"Moving", "Bounce", "Gravity", "Drag"};

FixedOrb earth;
Orb[] orbs;
int orbCount;

public void setup() {
  /* size commented out by preprocessor */;

  //Part 0: Write makeOrbs below
  makeOrbs(true);
  //Part 3: create earth to simulate gravity
  earth = null;

}//setup

public void draw() {
  background(255);
  displayMode();

  //draw the orbs and springs
  for (int o=0; o < orbCount; o++) {
    orbs[o].display();

    //Part 1: write drawSpring below
    //Use drawspring correctly to draw springs

  }//draw orbs & springs

  if (toggles[MOVING]) {
    //Part 2: write applySprings below
    applySprings();

    //part 3: apply other forces if toggled on
    for (int o=0; o < orbCount; o++) {

    }//gravity, drag

    for (int o=0; o < orbCount; o++) {
      orbs[o].move(toggles[BOUNCE]);
    }
  }//moving
}//draw

/* ===================================
  makeOrbs(boolean ordered)

  Set orbCount to NUM_ORBS
  Initialize and create orbCount Orbs in orbs.
  All orbs should have random mass and size.
  The first orb should be a FixedOrb
  If ordered is true:
    The orbs should be spaced SPRING_LENGTH distance
    apart along the middle of the screen.
  If ordered is false:
    The orbs should be positioned radomly.

  Each orb will be "connected" to its neighbors in the array.
=================================== */
public void makeOrbs(boolean ordered) {
  // orbCount = NUM_ORBS;
  // orbs = new Orb[orbCount];

}//makeOrbs


/* ===================================
  drawSpring(Orb o0, Orb o1)

  Draw a line between the two Orbs.
  Line color should change as follows:
    red: The spring is stretched.
    green: The spring is compressed.
    black: The spring is at its normal length
=================================== */
public void drawSpring(Orb o0, Orb o1) {

}//drawSpring


/* ===================================
  applySprings()

  Go through the Orbs array and apply the spring
  force correctly for each orb. We will consider every
  orb as being "connected" via a spring to is
  neighboring orbs in the array.
=================================== */
public void applySprings() {

}//applySprings

public void addOrb() {
  if (orbCount < orbs.length) {
    orbs[orbCount] = new Orb();
  }
  else {
    Orb[] neworbs = new Orb[orbCount+1];
    arrayCopy(orbs, neworbs);
    neworbs[orbCount] = new Orb();
    orbs = neworbs;
  }
}//addOrb



public void keyPressed() {
  if (key == ' ') { toggles[MOVING] = !toggles[MOVING]; }
  if (key == 'g') { toggles[GRAVITY] = !toggles[GRAVITY]; }
  if (key == 'b') { toggles[BOUNCE] = !toggles[BOUNCE]; }
  if (key == 'd') { toggles[DRAGF] = !toggles[DRAGF]; }
  if (key == '1') {
    makeOrbs(true);
  }
  if (key == '2') {
    makeOrbs(false);
  }
  if (key == '-') {
    if (orbCount > 0) {
      orbCount--;
      orbs[orbCount] = null;
    }
  }
  if (key == '=' || key == '+') {
    addOrb();
    orbCount++;
  }
}//keyPressed



public void displayMode() {
  textAlign(LEFT, TOP);
  textSize(20);
  noStroke();
  int spacing = 85;
  int x = 0;

  for (int m=0; m<toggles.length; m++) {
    //set box color
    if (toggles[m]) { fill(0, 255, 0); }
    else { fill(255, 0, 0); }

    float w = textWidth(modes[m]);
    rect(x, 0, w+5, 20);
    fill(0);
    text(modes[m], x+2, 2);
    x+= w+5;
  }
}//display
class FixedOrb extends Orb {

  FixedOrb(float x, float y, float s, float m) {
    super(x, y, s, m);
    c = color(255, 0, 0);
  }

  FixedOrb() {
    super();
    c = color(255, 0, 0);
  }

  public void move(boolean bounce) {
    //do nothing
  }

}//fixedOrb
class Orb {

  //instance variables
  PVector center;
  PVector velocity;
  PVector acceleration;
  float bsize;
  float mass;
  int c;


  Orb() {
     bsize = random(10, MAX_SIZE);
     float x = random(bsize/2, width-bsize/2);
     float y = random(bsize/2, height-bsize/2);
     center = new PVector(x, y);
     mass = random(10, 100);
     velocity = new PVector();
     acceleration = new PVector();
     setColor();
  }

  Orb(float x, float y, float s, float m) {
     bsize = s;
     mass = m;
     center = new PVector(x, y);
     velocity = new PVector();
     acceleration = new PVector();
     setColor();
   }

  //movement behavior
  public void move(boolean bounce) {
    if (bounce) {
      xBounce();
      yBounce();
    }

    velocity.add(acceleration);
    center.add(velocity);
    acceleration.mult(0);
  }//move

  public void applyForce(PVector force) {
    PVector scaleForce = force.copy();
    scaleForce.div(mass);
    acceleration.add(scaleForce);
  }

  public PVector getDragForce(float cd) {
    float dragMag = velocity.mag();
    dragMag = -0.5f * dragMag * dragMag * cd;
    PVector dragForce = velocity.copy();
    dragForce.normalize();
    dragForce.mult(dragMag);
    return dragForce;
  }

  public PVector getGravity(Orb other, float G) {
    float strength = G * mass*other.mass;
    //dont want to divide by 0!
    float r = max(center.dist(other.center), MIN_SIZE);
    strength = strength/ pow(r, 2);
    PVector force = other.center.copy();
    force.sub(center);
    force.mult(strength);
    return force;
  }

  //spring force between calling orb and other
  public PVector getSpring(Orb other, int springLength, float springK) {
    PVector direction = new PVector();

    return direction;
  }//getSpring

  public boolean yBounce(){
    if (center.y > height - bsize/2) {
      velocity.y *= -1;
      center.y = height - bsize/2;

      return true;
    }//bottom bounce
    else if (center.y < bsize/2) {
      velocity.y*= -1;
      center.y = bsize/2;
      return true;
    }
    return false;
  }//yBounce
  public boolean xBounce() {
    if (center.x > width - bsize/2) {
      center.x = width - bsize/2;
      velocity.x *= -1;
      return true;
    }
    else if (center.x < bsize/2) {
      center.x = bsize/2;
      velocity.x *= -1;
      return true;
    }
    return false;
  }//xbounce

  public boolean collisionCheck(Orb other) {
    return ( this.center.dist(other.center)
             <= (this.bsize/2 + other.bsize/2) );
  }//collisionCheck


  public void setColor() {
    int c0 = color(0, 255, 255);
    int c1 = color(0);
    c = lerpColor(c0, c1, (mass-MIN_SIZE)/(MAX_MASS-MIN_SIZE));
  }//setColor

  //visual behavior
  public void display() {
    noStroke();
    fill(c);
    circle(center.x, center.y, bsize);
    fill(0);
    //text(mass, center.x, center.y);
  }//display
}//Ball


  public void settings() { size(600, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "SpringArrayRunner" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
